name: Daily Subscription Converter

on:
  # این Workflow هر روز در ساعت 00:00 UTC (حدود 03:30 صبح به وقت ایران) اجرا می‌شود.
  # می‌توانید زمان را بر اساس نیاز خود تغییر دهید.
  # برای اطلاعات بیشتر در مورد Cron syntax: https://crontab.guru/
  schedule:
    - cron: '0 0 * * *' # هر روز ساعت 00:00 UTC

  # می‌توانید یک تریگر دستی هم اضافه کنید تا هر وقت خواستید آن را اجرا کنید.
  workflow_dispatch:

jobs:
  convert_and_push:
    runs-on: ubuntu-latest # از یک محیط لینوکس استفاده می‌کند.

    steps:
      - name: Checkout repository # کد مخزن را به محیط اجرا کپی می‌کند.
        uses: actions/checkout@v3

      - name: Cache Docker image for subconverter # کش کردن ایمیج داکر subconverter برای اجرای سریع‌تر
        id: cache-subconverter-docker
        uses: actions/cache@v3
        with:
          path: /var/lib/docker # مسیری که ایمیج‌های داکر در آن ذخیره می‌شوند.
          key: ${{ runner.os }}-docker-${{ hashFiles('**/Dockerfile') }} # کلید کش بر اساس سیستم عامل و تغییرات Dockerfile (اگر وجود داشته باشد)
          restore-keys: |
            ${{ runner.os }}-docker-

      - name: Pull subconverter Docker image # اطمینان از وجود آخرین ایمیج subconverter
        run: docker pull metacubex/subconverter:latest

      - name: Create base output directory # ایجاد پوشه اصلی برای ذخیره خروجی‌ها
        run: mkdir -p output_configs

      - name: Install yq # نصب yq برای خواندن فایل YAML
        run: sudo snap install yq

      - name: Read subconverter settings # خواندن تنظیمات از فایل YAML
        id: read_settings
        run: |
          SETTINGS_FILE="config/subconverter_settings.yml"
          ADVANCED_PARAMS=""

          if [ -f "$SETTINGS_FILE" ]; then
            echo "خواندن تنظیمات از: $SETTINGS_FILE"
            # لیست تمام پارامترهای پیشرفته که می‌خواهید از فایل settings.yml بخوانید
            # این لیست باید با پارامترهای پشتیبانی شده توسط subconverter API مطابقت داشته باشد.
            PARAMS=(
              "emoji" "add_emoji" "remove_emoji" "append_type" "tfo" "udp" "list" "sort"
              "script" "insert" "scv" "fdn" "expand" "append_info" "prepend" "classic"
              "tls13" "new_name" "ua" "interval" "dev_id" "filename" "exclude" "include" "rename"
            )

            for param in "${PARAMS[@]}"; do
              # استفاده از yq برای خواندن مقدار پارامتر. 2>/dev/null برای ساکت کردن خطاهای yq در صورت عدم وجود پارامتر.
              VALUE=$(yq e ".$param" "$SETTINGS_FILE" 2>/dev/null)
              
              # بررسی اینکه مقدار null نباشد و خالی نباشد
              if [ "$VALUE" != "null" ] && [ -n "$VALUE" ]; then
                # URL-encode کردن مقدار پارامتر برای استفاده در URL
                ENCODED_VALUE=$(python3 -c 'import urllib.parse; print(urllib.parse.quote(input(), safe=""))' <<< "$VALUE")
                ADVANCED_PARAMS+="&${param}=${ENCODED_VALUE}"
              fi
            done
            echo "ADVANCED_PARAMS=$ADVANCED_PARAMS" >> $GITHUB_OUTPUT
          else
            echo "فایل تنظیمات '$SETTINGS_FILE' یافت نشد. از تنظیمات پیش‌فرض subconverter استفاده می‌شود."
            echo "ADVANCED_PARAMS=" >> $GITHUB_OUTPUT
          fi

      - name: Start subconverter Docker container # راه‌اندازی کانتینر subconverter در حالت HTTP سرور
        run: |
          mkdir -p /tmp/subconverter_temp_data # ایجاد پوشه موقت روی هاست برای فایل‌های دیکد شده Base64
          # راه‌اندازی کانتینر با Mount کردن پوشه موقت
          docker run -d -p 25500:25500 -v /tmp/subconverter_temp_data:/app/temp_data --name subconverter_instance metacubex/subconverter:latest
          # صبر کردن برای آماده شدن سرویس subconverter
          echo "صبر کردن برای راه‌اندازی subconverter..."
          sleep 10 # 10 ثانیه معمولاً کافی است.
          
      - name: Process subscription files # پردازش فایل‌های سابسکریپشن
        run: |
          # مسیر پوشه حاوی فایل‌های سابسکریپشن ورودی
          INPUT_DIR="input_subs"
          # مسیر پوشه اصلی برای ذخیره فایل‌های کانفیگ تبدیل شده
          OUTPUT_BASE_DIR="output_configs"
          # پارامترهای پیشرفته از مرحله قبلی (خروجی read_settings)
          ADVANCED_PARAMS="${{ steps.read_settings.outputs.ADVANCED_PARAMS }}"
          
          # بررسی اینکه آیا پوشه ورودی وجود دارد یا خیر
          if [ ! -d "$INPUT_DIR" ]; then
            echo "پوشه ورودی '$INPUT_DIR' یافت نشد. لطفاً فایل‌های سابسکریپشن خود را در این پوشه قرار دهید."
            echo "عملیات تبدیل متوقف می‌شود."
            exit 0 # Workflow با موفقیت پایان می‌یابد اما عملیات تبدیل انجام نمی‌شود.
          fi

          # حلقه برای پردازش هر فایل .txt در پوشه ورودی
          # از find برای اطمینان از یافتن فقط فایل‌ها و مدیریت بهتر نام‌ها استفاده می‌شود.
          find "$INPUT_DIR" -maxdepth 1 -type f -name "*.txt" | while read sub_file; do
            echo "در حال پردازش فایل: $sub_file"
            
            # استخراج نام فایل بدون پسوند (مثلا "clash" از "clash.txt") که به عنوان TARGET_FORMAT استفاده می‌شود
            TARGET_FORMAT=$(basename "$sub_file" | sed 's/\.txt$//')
            
            # ایجاد زیرپوشه خروجی برای این فرمت هدف (مثلا output_configs/clash)
            CURRENT_OUTPUT_DIR="${OUTPUT_BASE_DIR}/${TARGET_FORMAT}"
            mkdir -p "$CURRENT_OUTPUT_DIR"
            echo "ایجاد پوشه خروجی: $CURRENT_OUTPUT_DIR"

            LINE_COUNT=0
            # خواندن هر خط از فایل
            while IFS= read -r line; do
              LINE_COUNT=$((LINE_COUNT+1))
              trimmed_line=$(echo "$line" | xargs) # حذف فضای خالی اطراف خط

              if [ -n "$trimmed_line" ]; then # اگر خط خالی نباشد
                # جداسازی لینک، نام فایل دلخواه و نوع پردازش
                # Expected format: URL,FILENAME_BASE[,PROCESSING_TYPE]
                URL_TO_CONVERT_RAW=$(echo "$trimmed_line" | cut -d',' -f1)
                SECOND_PART=$(echo "$trimmed_line" | cut -d',' -f2-) # می‌تونه شامل FILENAME_BASE یا FILENAME_BASE,PROCESSING_TYPE باشه

                if [[ "$SECOND_PART" == *","* ]]; then
                    # اگر دو کاما یا بیشتر وجود دارد، یعنی FILENAME_BASE و PROCESSING_TYPE هر دو هستند
                    CUSTOM_OUTPUT_BASE_NAME=$(echo "$SECOND_PART" | cut -d',' -f1)
                    PROCESSING_TYPE=$(echo "$SECOND_PART" | cut -d',' -s -f2) # -s برای جلوگیری از خطا اگر فیلد دوم وجود ندارد
                else
                    # اگر فقط یک کاما یا بدون کاما باشد
                    CUSTOM_OUTPUT_BASE_NAME="$SECOND_PART"
                    PROCESSING_TYPE="" # پیش‌فرض: پردازش مستقیم
                fi

                # تمیز کردن نام فایل سفارشی: حذف کاراکترهای نامعتبر و جایگزینی با '_'
                CUSTOM_OUTPUT_BASE_NAME=$(echo "$CUSTOM_OUTPUT_BASE_NAME" | sed 's/[^a-zA-Z0-9._-]/_/g')

                # تعیین نام فایل خروجی نهایی
                if [ -z "$CUSTOM_OUTPUT_BASE_NAME" ]; then
                    OUTPUT_FILENAME="${TARGET_FORMAT}_$(printf "%03d" $LINE_COUNT).yaml"
                    echo "  هشدار: خط #$LINE_COUNT در فایل '$sub_file' نام فایل سفارشی ندارد. از نام پیش‌فرض استفاده می‌شود."
                else
                    OUTPUT_FILENAME="${CUSTOM_OUTPUT_BASE_NAME}.yaml"
                fi

                OUTPUT_FILE_PATH_IN_WORKSPACE="${CURRENT_OUTPUT_DIR}/${OUTPUT_FILENAME}"

                # بررسی اینکه بخش URL واقعاً یک URL باشد (یک بررسی ساده)
                if [[ "$URL_TO_CONVERT_RAW" =~ ^https?:// ]]; then
                    URL_FOR_SUBVERTER="" # این متغیر URL نهایی را که subconverter استفاده می‌کند، نگه می‌دارد

                    if [ "$PROCESSING_TYPE" == "base64" ]; then
                        echo "  در حال پردازش Base64 برای لینک #$LINE_COUNT از فایل '$sub_file'..."
                        # ایجاد یک فایل موقت در پوشه Mount شده برای ذخیره محتوای دیکد شده
                        TEMP_DECODED_FILE=$(mktemp /tmp/subconverter_temp_data/decoded_XXXXXX.txt)
                        
                        # دریافت محتوای Base64 از URL اصلی و دیکد کردن مستقیم به فایل موقت
                        # Redirect stderr of base64 -d to stdout for debugging
                        curl -s -S "$URL_TO_CONVERT_RAW" | base64 -d > "$TEMP_DECODED_FILE" 2>&1
                        CURL_BASE64_EXIT_CODE=$? # Get exit code of base64 -d
                        
                        # Check if base64 decoding failed or if the fetched content was empty/invalid
                        if [ "$CURL_BASE64_EXIT_CODE" -ne 0 ] || [ ! -s "$TEMP_DECODED_FILE" ]; then
                            echo "  خطا در دریافت یا دیکد کردن Base64 محتوا از $URL_TO_CONVERT_RAW (کد خطا: $CURL_BASE64_EXIT_CODE). محتوا ممکن است Base64 معتبر نباشد یا لینک نامعتبر باشد. رد می‌شود."
                            echo "Error: Failed to fetch or Base64 decode content. Check GitHub Actions logs for details." > "$OUTPUT_FILE_PATH_IN_WORKSPACE"
                            rm -f "$TEMP_DECODED_FILE" # حذف فایل موقت
                            continue # پرش به خط بعدی
                        fi
                        
                        # ساخت URL file:// برای subconverter (مسیر داخل کانتینر)
                        URL_FOR_SUBVERTER="file:///app/temp_data/$(basename "$TEMP_DECODED_FILE")"
                        echo "  محتوای دیکد شده در '$TEMP_DECODED_FILE' ذخیره شد. subconverter از '$URL_FOR_SUBVERTER' استفاده خواهد کرد."
                    else
                        # URL-encode کردن لینک تکی با استفاده از پایتون برای پردازش مستقیم
                        URL_FOR_SUBVERTER=$(python3 -c 'import urllib.parse; print(urllib.parse.quote(input(), safe=""))' <<< "$URL_TO_CONVERT_RAW")
                        echo "  در حال تبدیل مستقیم لینک #$LINE_COUNT از فایل '$sub_file' به فرمت '$TARGET_FORMAT'..."
                    fi
                    
                    # ساخت URL کامل برای درخواست به API محلی subconverter
                    # شامل لینک سابسکریپشن (که ممکن است file:// باشد) و پارامترهای پیشرفته
                    FULL_API_URL="http://localhost:25500/sub?target=${TARGET_FORMAT}&url=${URL_FOR_SUBVERTER}${ADVANCED_PARAMS}"
                    
                    # ارسال درخواست curl به subconverter محلی و ذخیره خروجی
                    curl -s -S -o "$OUTPUT_FILE_PATH_IN_WORKSPACE" "$FULL_API_URL"
                    
                    # بررسی وضعیت خروج دستور curl
                    CURL_EXIT_CODE=$?
                    if [ "$CURL_EXIT_CODE" -eq 0 ]; then
                      echo "  تبدیل لینک #$LINE_COUNT با موفقیت انجام شد. خروجی در '${OUTPUT_FILE_PATH_IN_WORKSPACE}' ذخیره شد."
                    else
                      echo "  خطا در تبدیل لینک #$LINE_COUNT از فایل '$sub_file' (کد خطا: $CURL_EXIT_CODE). لطفاً لاگ‌های GitHub Actions را برای جزئیات بیشتر بررسی کنید."
                      echo "  این لینک ممکن است نامعتبر باشد یا subconverter نتواند آن را پردازش کند. به پردازش لینک‌های بعدی ادامه می‌دهیم."
                      echo "Error: Failed to convert this link. Check GitHub Actions logs for details." > "$OUTPUT_FILE_PATH_IN_WORKSPACE"
                    fi
                else
                    echo "  خطا: خط #$LINE_COUNT در فایل '$sub_file' حاوی URL معتبری نیست: '$URL_TO_CONVERT_RAW'. از آن رد می‌شویم."
                fi
              else
                echo "  خط #$LINE_COUNT در فایل '$sub_file' خالی است. از آن رد می‌شویم."
              fi
            done < "$sub_file"
            
            # اگر هیچ لینکی در فایل یافت نشد، یک پیام بدهید
            if [ "$LINE_COUNT" -eq 0 ]; then
              echo "فایل '$sub_file' هیچ لینک معتبری برای تبدیل نداشت."
            fi
          done

      - name: Stop subconverter Docker container # توقف کانتینر subconverter
        if: always() # همیشه اجرا شود، حتی اگر مراحل قبلی خطا داشته باشند
        run: |
          echo "توقف و حذف کانتینر subconverter..."
          docker stop subconverter_instance || true # `|| true` برای جلوگیری از خطا در صورت عدم وجود کانتینر
          docker rm subconverter_instance || true # `|| true` برای جلوگیری از خطا در صورت عدم وجود کانتینر

      - name: Clean up temporary files # حذف فایل‌های موقت
        if: always() # همیشه اجرا شود
        run: |
          echo "حذف فایل‌های موقت..."
          rm -rf /tmp/subconverter_temp_data || true # `|| true` برای جلوگیری از خطا در صورت عدم وجود پوشه

      - name: Configure Git user # پیکربندی اطلاعات Git برای commit کردن تغییرات
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Commit and push changes # commit کردن فایل‌های تبدیل شده و push آن‌ها به مخزن
        run: |
          # بررسی اینکه آیا پوشه خروجی وجود دارد و خالی نیست
          if [ -d "output_configs" ] && [ "$(ls -A output_configs)" ]; then
            git add output_configs # اضافه کردن کل پوشه خروجی برای commit
            git commit -m "Update converted configs from daily subconverter action" || echo "No changes to commit" # اگر تغییری نبود، خطا نمی‌دهد.
            git push
          else
            echo "پوشه 'output_configs' خالی است یا وجود ندارد. هیچ تغییری برای commit وجود ندارد."
          fi
