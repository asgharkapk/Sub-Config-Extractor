name: Daily Subscription Converter

on:
  # این Workflow هر روز در ساعت 00:00 UTC (حدود 03:30 صبح به وقت ایران) اجرا می‌شود.
  # می‌توانید زمان را بر اساس نیاز خود تغییر دهید.
  # برای اطلاعات بیشتر در مورد Cron syntax: https://crontab.guru/
  schedule:
    - cron: '0 0 * * *' # هر روز ساعت 00:00 UTC

  # می‌توانید یک تریگر دستی هم اضافه کنید تا هر وقت خواستید آن را اجرا کنید.
  workflow_dispatch:

jobs:
  convert_and_push:
    runs-on: ubuntu-latest # از یک محیط لینوکس استفاده می‌کند.

    steps:
      - name: Checkout repository # کد مخزن را به محیط اجرا کپی می‌کند.
        uses: actions/checkout@v3
        with:
          # برای اینکه بتوانیم در طول Workflow چندین بار push کنیم، نیاز به توکن داریم.
          # GITHUB_TOKEN به صورت خودکار توسط GitHub Actions فراهم می‌شود.
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Cache Docker image for subconverter # کش کردن ایمیج داکر subconverter برای اجرای سریع‌تر
        id: cache-subconverter-docker
        uses: actions/cache@v3
        with:
          path: /var/lib/docker # مسیری که ایمیج‌های داکر در آن ذخیره می‌شوند.
          key: ${{ runner.os }}-docker-${{ hashFiles('**/Dockerfile') }} # کلید کش بر اساس سیستم عامل و تغییرات Dockerfile (اگر وجود داشته باشد)
          restore-keys: |
            ${{ runner.os }}-docker-

      - name: Pull subconverter Docker image # اطمینان از وجود آخرین ایمیج subconverter
        run: docker pull metacubex/subconverter:latest

      - name: Create base output directories # ایجاد پوشه‌های اصلی برای ذخیره خروجی‌ها
        run: |
          mkdir -p output_configs
          mkdir -p output_configs/base64 # ایجاد پوشه برای فایل‌های Base64 شده

      - name: Install yq # نصب yq برای خواندن فایل YAML
        run: sudo snap install yq

      - name: Configure Git user for intermediate push # پیکربندی اطلاعات Git برای commitهای میانی
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Read subconverter settings # خواندن تنظیمات از فایل YAML
        id: read_settings
        run: |
          SETTINGS_FILE="config/subconverter_settings.yml"
          ADVANCED_PARAMS=""

          if [ -f "$SETTINGS_FILE" ]; then
            echo "خواندن تنظیمات از: $SETTINGS_FILE"
            # لیست تمام پارامترهای پیشرفته که می‌خواهید از فایل settings.yml بخوانید
            # این لیست باید با پارامترهای پشتیبانی شده توسط subconverter API مطابقت داشته باشد.
            PARAMS=(
              "emoji" "add_emoji" "remove_emoji" "append_type" "tfo" "udp" "list" "sort"
              "script" "insert" "scv" "fdn" "expand" "append_info" "prepend" "classic"
              "tls13" "new_name" "ua" "interval" "dev_id" "filename" "exclude" "include" "rename"
            )

            for param in "${PARAMS[@]}"; do
              # استفاده از yq برای خواندن مقدار پارامتر. 2>/dev/null برای ساکت کردن خطاهای yq در صورت عدم وجود پارامتر.
              VALUE=$(yq e ".$param" "$SETTINGS_FILE" 2>/dev/null)
              
              # بررسی اینکه مقدار null نباشد و خالی نباشد
              if [ "$VALUE" != "null" ] && [ -n "$VALUE" ]; then
                # URL-encode کردن مقدار پارامتر برای استفاده در URL
                ENCODED_VALUE=$(python3 -c 'import urllib.parse; print(urllib.parse.quote(input(), safe=""))' <<< "$VALUE")
                ADVANCED_PARAMS+="&${param}=${ENCODED_VALUE}"
              fi
            done
            echo "ADVANCED_PARAMS=$ADVANCED_PARAMS" >> $GITHUB_OUTPUT
          else
            echo "فایل تنظیمات '$SETTINGS_FILE' یافت نشد. از تنظیمات پیش‌فرض subconverter استفاده می‌شود."
            echo "ADVANCED_PARAMS=" >> $GITHUB_OUTPUT
          fi

      - name: Prepare and Push Base64 Files # آماده‌سازی و Push فایل‌های Base64
        id: prepare_base64
        run: |
          INPUT_DIR="input_subs"
          OUTPUT_BASE_DIR="output_configs"
          
          echo "مرحله اول: آماده‌سازی فایل‌های Base64 برای آپلود."
          BASE64_FILES_GENERATED=false

          find "$INPUT_DIR" -maxdepth 1 -type f -name "*.txt" | while read sub_file; do
            echo "در حال بررسی فایل: $sub_file"
            TARGET_FORMAT=$(basename "$sub_file" | sed 's/\.txt$//')
            LINE_COUNT=0
            while IFS= read -r line; do
              LINE_COUNT=$((LINE_COUNT+1))
              trimmed_line=$(echo "$line" | xargs)

              if [ -n "$trimmed_line" ]; then
                URL_TO_CONVERT_RAW=""
                CUSTOM_OUTPUT_BASE_NAME=""
                NEEDS_BASE64_CONVERSION=false

                if [[ "$trimmed_line" == *",base64" ]]; then
                  NEEDS_BASE64_CONVERSION=true
                  temp_line="${trimmed_line%,base64}"
                  URL_TO_CONVERT_RAW=$(echo "$temp_line" | cut -d',' -f1)
                  CUSTOM_OUTPUT_BASE_NAME=$(echo "$temp_line" | cut -d',' -f2-)
                elif [[ "$trimmed_line" == *,* ]]; then
                  URL_TO_CONVERT_RAW=$(echo "$trimmed_line" | cut -d',' -f1)
                  CUSTOM_OUTPUT_BASE_NAME=$(echo "$trimmed_line" | cut -d',' -f2-)
                else
                  URL_TO_CONVERT_RAW="$trimmed_line"
                fi

                if [ -n "$CUSTOM_OUTPUT_BASE_NAME" ]; then
                  CUSTOM_OUTPUT_BASE_NAME_CLEANED=$(echo "$CUSTOM_OUTPUT_BASE_NAME" | sed 's/[^a-zA-Z0-9._-]/_/g')
                else
                  # If no custom name, use a default for the Base64 file as well
                  CUSTOM_OUTPUT_BASE_NAME_CLEANED="${TARGET_FORMAT}_$(printf "%03d" $LINE_COUNT)_base64"
                fi

                if [ "$NEEDS_BASE64_CONVERSION" = true ]; then
                  echo "  در حال دریافت و تبدیل Base64 برای لینک #$LINE_COUNT: $URL_TO_CONVERT_RAW"
                  FETCHED_CONTENT=$(curl -s -S "$URL_TO_CONVERT_RAW")
                  FETCH_EXIT_CODE=$?

                  if [ "$FETCH_EXIT_CODE" -eq 0 ]; then
                    BASE64_CONTENT=$(echo "$FETCHED_CONTENT" | python3 -c 'import base64, sys; print(base64.b64encode(sys.stdin.buffer.read()).decode("utf-8"))')
                    
                    BASE64_FILE_NAME="${CUSTOM_OUTPUT_BASE_NAME_CLEANED}.txt"
                    BASE64_FILE_PATH="${OUTPUT_BASE_DIR}/base64/${BASE64_FILE_NAME}"
                    echo "$BASE64_CONTENT" > "$BASE64_FILE_PATH"
                    echo "  محتوای Base64 شده در '$BASE64_FILE_PATH' ذخیره شد."
                    BASE64_FILES_GENERATED=true
                  else
                    echo "  خطا: نتوانستیم محتوای لینک Base64 اصلی را دریافت کنیم: $URL_TO_CONVERT_RAW (کد خطا: $FETCH_EXIT_CODE)."
                    echo "  از این لینک صرف نظر می‌کنیم."
                  fi
                fi
              fi
            done < "$sub_file"
          done

          echo "BASE64_FILES_GENERATED=$BASE64_FILES_GENERATED" >> $GITHUB_OUTPUT

          if [ "$BASE64_FILES_GENERATED" = true ]; then
            echo "مرحله دوم: Commit و Push فایل‌های Base64."
            git add "${OUTPUT_BASE_DIR}/base64"
            git commit -m "Upload Base64 intermediate files" || echo "No new Base64 files to commit."
            git push
            echo "فایل‌های Base64 به مخزن Push شدند. صبر کردن برای در دسترس قرار گرفتن Raw URL ها..."
            sleep 10 # به GitHub کمی زمان بدهید تا push را پردازش کند و Raw URLها را در دسترس قرار دهد.
          else
            echo "هیچ فایل Base64 جدیدی برای Commit نیست."
          fi

      - name: Start subconverter Docker container # راه‌اندازی کانتینر subconverter در حالت HTTP سرور
        run: |
          docker run -d -p 25500:25500 --name subconverter_instance metacubex/subconverter:latest
          # صبر کردن برای آماده شدن سرویس subconverter
          echo "صبر کردن برای راه‌اندازی subconverter..."
          sleep 10 # 10 ثانیه معمولاً کافی است.
          
      - name: Process subscription files # پردازش فایل‌های سابسکریپشن
        run: |
          INPUT_DIR="input_subs"
          OUTPUT_BASE_DIR="output_configs"
          ADVANCED_PARAMS="${{ steps.read_settings.outputs.ADVANCED_PARAMS }}"
          
          if [ ! -d "$INPUT_DIR" ]; then
            echo "پوشه ورودی '$INPUT_DIR' یافت نشد. لطفاً فایل‌های سابسکریپشن خود را در این پوشه قرار دهید."
            echo "عملیات تبدیل متوقف می‌شود."
            exit 0
          fi

          echo "مرحله سوم: پردازش سابسکریپشن‌ها با subconverter."
          find "$INPUT_DIR" -maxdepth 1 -type f -name "*.txt" | while read sub_file; do
            echo "در حال پردازش فایل: $sub_file"
            
            TARGET_FORMAT=$(basename "$sub_file" | sed 's/\.txt$//')
            CURRENT_OUTPUT_DIR="${OUTPUT_BASE_DIR}/${TARGET_FORMAT}"
            mkdir -p "$CURRENT_OUTPUT_DIR"
            echo "ایجاد پوشه خروجی: $CURRENT_OUTPUT_DIR"

            LINE_COUNT=0
            while IFS= read -r line; do
              LINE_COUNT=$((LINE_COUNT+1))
              trimmed_line=$(echo "$line" | xargs)

              if [ -n "$trimmed_line" ]; then
                URL_TO_CONVERT_RAW=""
                CUSTOM_OUTPUT_BASE_NAME=""
                NEEDS_BASE64_CONVERSION=false

                if [[ "$trimmed_line" == *",base64" ]]; then
                  NEEDS_BASE64_CONVERSION=true
                  temp_line="${trimmed_line%,base64}"
                  URL_TO_CONVERT_RAW=$(echo "$temp_line" | cut -d',' -f1)
                  CUSTOM_OUTPUT_BASE_NAME=$(echo "$temp_line" | cut -d',' -f2-)
                elif [[ "$trimmed_line" == *,* ]]; then
                  URL_TO_CONVERT_RAW=$(echo "$trimmed_line" | cut -d',' -f1)
                  CUSTOM_OUTPUT_BASE_NAME=$(echo "$trimmed_line" | cut -d',' -f2-)
                else
                  URL_TO_CONVERT_RAW="$trimmed_line"
                fi

                # تعیین نام فایل خروجی برای فایل YAML
                if [ -n "$CUSTOM_OUTPUT_BASE_NAME" ]; then
                  CUSTOM_OUTPUT_BASE_NAME_CLEANED=$(echo "$CUSTOM_OUTPUT_BASE_NAME" | sed 's/[^a-zA-Z0-9._-]/_/g')
                  OUTPUT_FILENAME="${CUSTOM_OUTPUT_BASE_NAME_CLEANED}.yaml"
                else
                  OUTPUT_FILENAME="${TARGET_FORMAT}_$(printf "%03d" $LINE_COUNT).yaml"
                  echo "  هشدار: خط #$LINE_COUNT در فایل '$sub_file' فرمت 'URL,FILENAME' را ندارد. از نام پیش‌فرض استفاده می‌شود."
                fi

                if [[ "$URL_TO_CONVERT_RAW" =~ ^https?:// ]]; then
                    echo "  در حال تبدیل لینک #$LINE_COUNT از فایل '$sub_file' به فرمت '$TARGET_FORMAT'..."
                    
                    FINAL_URL_FOR_SUBCONVERTER=""

                    if [ "$NEEDS_BASE64_CONVERSION" = true ]; then
                        # ساخت URL خام GitHub برای فایل Base64 شده
                        # اطمینان حاصل کنید که CUSTOM_OUTPUT_BASE_NAME_CLEANED با آنچه در مرحله قبلی استفاده شد، مطابقت دارد.
                        BASE64_FILE_NAME_FOR_RAW_URL="${CUSTOM_OUTPUT_BASE_NAME_CLEANED:-${TARGET_FORMAT}_$(printf "%03d" $LINE_COUNT)_base64}.txt"
                        FINAL_URL_FOR_SUBCONVERTER="https://raw.githubusercontent.com/${{ github.repository }}/${{ github.ref_name }}/${OUTPUT_BASE_DIR}/base64/${BASE64_FILE_NAME_FOR_RAW_URL}"
                        echo "  استفاده از URL خام Base64: $FINAL_URL_FOR_SUBCONVERTER"
                    else
                        FINAL_URL_FOR_SUBCONVERTER="$URL_TO_CONVERT_RAW"
                    fi
                    
                    # URL-encode کردن لینک نهایی با استفاده از پایتون
                    URL_TO_CONVERT=$(python3 -c 'import urllib.parse; print(urllib.parse.quote(input(), safe=""))' <<< "$FINAL_URL_FOR_SUBCONVERTER")
                    
                    OUTPUT_FILE_PATH_IN_WORKSPACE="${CURRENT_OUTPUT_DIR}/${OUTPUT_FILENAME}"

                    FULL_API_URL="http://localhost:25500/sub?target=${TARGET_FORMAT}&url=${URL_TO_CONVERT}${ADVANCED_PARAMS}"
                    
                    # ارسال درخواست curl به subconverter محلی و ذخیره خروجی
                    curl -s -S -o "$OUTPUT_FILE_PATH_IN_WORKSPACE" "$FULL_API_URL"
                    
                    CURL_EXIT_CODE=$?
                    if [ "$CURL_EXIT_CODE" -eq 0 ]; then
                      echo "  تبدیل لینک #$LINE_COUNT با موفقیت انجام شد. خروجی در '${OUTPUT_FILE_PATH_IN_WORKSPACE}' ذخیره شد."
                    else
                      echo "  خطا در تبدیل لینک #$LINE_COUNT از فایل '$sub_file' (کد خطا: $CURL_EXIT_CODE). لطفاً لاگ‌های GitHub Actions را برای جزئیات بیشتر بررسی کنید."
                      echo "  این لینک ممکن است نامعتبر باشد یا subconverter نتواند آن را پردازش کند. به پردازش لینک‌های بعدی ادامه می‌دهیم."
                      echo "Error: Failed to convert this link. Check GitHub Actions logs for details." > "$OUTPUT_FILE_PATH_IN_WORKSPACE"
                    fi
                else
                    echo "  خطا: خط #$LINE_COUNT در فایل '$sub_file' حاوی URL معتبری نیست: '$URL_TO_CONVERT_RAW'. از آن رد می‌شویم."
                fi
              else
                echo "  خط #$LINE_COUNT در فایل '$sub_file' خالی است. از آن رد می‌شویم."
              fi
            done < "$sub_file"
            
            if [ "$LINE_COUNT" -eq 0 ]; then
              echo "فایل '$sub_file' هیچ لینک معتبری برای تبدیل نداشت."
            fi
          done

      - name: Stop subconverter Docker container # توقف کانتینر subconverter
        if: always() # همیشه اجرا شود، حتی اگر مراحل قبلی خطا داشته باشند
        run: |
          echo "توقف و حذف کانتینر subconverter..."
          docker stop subconverter_instance || true # `|| true` برای جلوگیری از خطا در صورت عدم وجود کانتینر
          docker rm subconverter_instance || true # `|| true` برای جلوگیری از خطا در صورت عدم وجود کانتینر

      - name: Commit and push final changes # commit کردن فایل‌های تبدیل شده و push آن‌ها به مخزن
        run: |
          # بررسی اینکه آیا پوشه خروجی وجود دارد و خالی نیست
          if [ -d "output_configs" ] && [ "$(ls -A output_configs)" ]; then
            git add output_configs # اضافه کردن کل پوشه خروجی برای commit
            git commit -m "Update converted configs from daily subconverter action" || echo "No changes to commit" # اگر تغییری نبود، خطا نمی‌دهد.
            git push
          else
            echo "پوشه 'output_configs' خالی است یا وجود ندارد. هیچ تغییری برای commit وجود ندارد."
          fi
